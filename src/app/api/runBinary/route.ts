import { NextRequest, NextResponse } from 'next/server';
import { execFile } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import fetch from 'node-fetch';
import semver from 'semver';  
import dotenv from 'dotenv';
import { GitHubRelease } from '@/app/types';
import { GIHHUB_RELEASES_URL } from '@/app/urls';
dotenv.config();

const execFilePromise = promisify(execFile);

const BINARY_FOLDER_PATH = '/tmp/binaries'
const BINARY_LOCAL_PATH = path.join(BINARY_FOLDER_PATH, 'renamer-linux');

async function getLatestReleaseInfo() {
    const response = await fetch(GIHHUB_RELEASES_URL);
    if (!response.ok) {
        throw new Error('Failed to fetch release info from GitHub.');
    }

    const releaseData: GitHubRelease = await response.json() as GitHubRelease;
    const latestVersion = releaseData.tag_name.replace('v', '');  
    const asset = releaseData.assets.find(asset => asset.name.toLowerCase().includes('linux'));
    if (!asset) {
        throw new Error('Could not find renamer-linux in the release assets.');
    }

    const downloadUrl = asset.browser_download_url;
    return { latestVersion, downloadUrl };
}

function getLocalBinaryVersion() {
    const versionFilePath = path.join('/tmp/binaries', 'version.txt');
    if (fs.existsSync(versionFilePath)) {
        return fs.readFileSync(versionFilePath, 'utf8').trim();
    }
    return null; 
}

async function downloadBinary(url : string) {
    if (!fs.existsSync(BINARY_FOLDER_PATH)) {
        fs.mkdirSync(BINARY_FOLDER_PATH, { recursive: true }); 
    }
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error('Failed to download binary.');
    }
    const responseBody = response.body;
    if (!responseBody) {
        throw new Error('Response body is null.');
    }
    const fileStream = fs.createWriteStream(BINARY_LOCAL_PATH);
    await new Promise((resolve, reject) => {
        responseBody.pipe(fileStream);
        responseBody.on('error', reject);
        fileStream.on('finish', resolve);
    });

    console.log('Binary downloaded successfully.');
}

function saveLocalBinaryVersion(version: string) {
    const versionFilePath = path.join('/tmp/binaries', 'version.txt');
    fs.writeFileSync(versionFilePath, version);
}

export async function POST(req: NextRequest) {
    const paths = {
        tempDir: '',
        tempFilePath: '',
        outputJsonFile: 'output.json'
    };

    try {
        const { fileName, fileContent, debug } = await req.json();

        if (!fileName || !fileContent) {
            return NextResponse.json({ error: 'fileName and fileContent are required.' }, { status: 400 }); 
        }

        const { latestVersion, downloadUrl } = await getLatestReleaseInfo();

        const localVersion = getLocalBinaryVersion();

        if (!localVersion || semver.lt(localVersion, latestVersion)) {
            console.log(`Downloading latest binary (version ${latestVersion})...`);
            await downloadBinary(downloadUrl);
            saveLocalBinaryVersion(latestVersion);
        } else {
            console.log(`Local binary is up-to-date (version ${localVersion}).`);
        }

        paths.tempDir = '/tmp/temp';
        if (!fs.existsSync(paths.tempDir)) {
            fs.mkdirSync(paths.tempDir);
        }

        paths.tempFilePath = path.join(paths.tempDir, fileName);
        fs.writeFileSync(paths.tempFilePath, fileContent, 'utf8');

        const args = ['--path', paths.tempFilePath, '-o', paths.outputJsonFile];
        if (debug) {
            args.push('--debug');
        }

        const { stderr } = await execFilePromise(BINARY_LOCAL_PATH, args, {
            env: {
                ...process.env,
                OPENAI_API_KEY: process.env.OPENAI_API_KEY,
            },
        });

        if (stderr) {
            console.error('Binary error:', stderr);
        }

        if (!fs.existsSync(paths.outputJsonFile)) {
            return NextResponse.json({ error: 'Output JSON file was not generated by the binary.' }, { status: 500 });
        }

        const jsonData = fs.readFileSync(paths.outputJsonFile, 'utf8');
        const renamedFiles = JSON.parse(jsonData);

        return NextResponse.json({ renamedFiles });

    } catch (error) {
        console.error('Error processing file:', error);
        return NextResponse.json({ error: 'Failed to process the file.' }, { status: 500 });
    } finally {
        try {
            if (fs.existsSync(paths.outputJsonFile)) {
                fs.unlinkSync(paths.outputJsonFile);
            }

            if (paths.tempFilePath && fs.existsSync(paths.tempFilePath)) {
                fs.unlinkSync(paths.tempFilePath);
            }

            if (paths.tempDir && fs.existsSync(paths.tempDir)) {
                fs.rmdirSync(paths.tempDir, { recursive: true });
            }
        } catch (cleanupError) {
            console.error('Error during cleanup:', cleanupError);
        }
    }
}
