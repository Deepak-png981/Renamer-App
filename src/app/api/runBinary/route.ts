import { NextRequest, NextResponse } from 'next/server';
import { execFile } from 'child_process';
import { promisify } from 'util';
import dotenv from 'dotenv';
import path from 'path';
import { getLatestReleaseInfo, getLocalBinaryVersion, downloadBinary, saveLocalBinaryVersion } from './binaryManager';
import { createTempDir, writeFile, readFile, removeFile, removeDir, fileExists } from './fileOperations';
import semver from 'semver';
import { isRateLimited } from './rateLimit';
import { contentDirectoryFile } from '@/app/types';
dotenv.config();


const execFilePromise = promisify(execFile);
const BINARY_LOCAL_PATH = path.join('/tmp/binaries', 'renamer-linux');

export async function POST(req: NextRequest) {
    const ip = req.headers.get('x-forwarded-for') || req.ip || 'unknown';

    if (isRateLimited(ip)) {
        return NextResponse.json({ error: 'Too many requests. Please try again later.' }, { status: 429 });
    }

    const paths = {
        tempDir: '',
        tempFilePath: '',
        outputJsonFile: path.join('/tmp', 'output.json'),
    };

    try {
        const { fileName, fileContent,contentDirectory, debug, namingConvention = 'camelCase' } = await req.json();

        if (!fileName && !contentDirectory) {
            return NextResponse.json({ error: 'fileName or contentDirectory is required.' }, { status: 400 });
        }

        const { latestVersion, downloadUrl } = await getLatestReleaseInfo();
        const localVersion = getLocalBinaryVersion();

        if (!localVersion || semver.lt(localVersion, latestVersion)) {
            console.log(`Downloading latest binary (version ${latestVersion})...`);
            console.log('Time before downloading the binary:', Date.now());
            await downloadBinary(downloadUrl);
            console.log('Time after downloading the binary:', Date.now());
            saveLocalBinaryVersion(latestVersion);
        } else {
            console.log(`Local binary is up-to-date (version ${localVersion}).`);
        }

        if (contentDirectory && contentDirectory.files && Array.isArray(contentDirectory.files)) {
            paths.tempDir = createTempDir('/tmp/contentDir');
            contentDirectory.files.forEach((file : contentDirectoryFile) => {
                const tempFilePath = path.join(paths.tempDir, file.fileName);
                writeFile(tempFilePath, file.content); 
            });

            paths.tempFilePath = paths.tempDir; 
        } else if (fileName && fileContent) {
            paths.tempDir = createTempDir('/tmp');
            paths.tempFilePath = path.join(paths.tempDir, fileName);
            writeFile(paths.tempFilePath, fileContent);
        } else {
            return NextResponse.json({ error: 'Invalid input: either fileName/fileContent or contentDirectory is required.' }, { status: 400 });
        }
        
        const args = ['--path', paths.tempFilePath, '-o', paths.outputJsonFile , '--namingConvention', namingConvention];
        if (debug) {
            args.push('--debug');
        }

        const { stdout, stderr } = await execFilePromise(BINARY_LOCAL_PATH, args, {
            env: {
                ...process.env,
                OPENAI_API_KEY: process.env.OPENAI_API_KEY,
            },
        });
        console.log('stdout:', stdout);
        if (stderr) {
            console.error('Binary error:', stderr);
        }

        if (!fileExists(paths.outputJsonFile)) {
            return NextResponse.json({ error: 'Output JSON file was not generated by the binary.' }, { status: 500 });
        }

        const jsonData = readFile(paths.outputJsonFile);
        const renamedFiles = JSON.parse(jsonData);

        return NextResponse.json({ renamedFiles });

    } catch (error) {
        console.error('Error processing file:', error);
        return NextResponse.json({ error: 'Failed to process the file.' }, { status: 500 });
    } finally {
        try {
            removeFile(paths.outputJsonFile);
            removeFile(paths.tempFilePath);
            removeDir(paths.tempDir);
        } catch (cleanupError) {
            console.error('Error during cleanup:', cleanupError);
        }
    }
}
